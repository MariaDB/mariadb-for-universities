<!doctype html><html lang=en><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><title>MariaDB for Universities Program: Course Material</title>
<link rel=stylesheet href=/css/main.css><meta property="og:url" content="https://uni.mariadb.org/dev/database-design/"><meta property="og:site_name" content="MariaDB for Universities Program Course Material"><meta property="og:title" content="Lesson 3: Database design"><meta property="og:description" content="Database design Learning objectives Explain the purpose of data modeling and database design Describe how MariaDB data types affect performance Assign appropriate column options Data modeling and database design Database mindset Redundant data is eliminated
Easier updating and maintenance
Atomicity, Isolation, Consistency, Durability (ACID)
Field have explicit data types
Flexible and easy to query programmatically
Accessible by multiple remote, differing clients
Multiple ways to view the same dataset
Indexable
Naming convention Consistent, Descriptive Names Reduce Mistakes"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="dev"><meta property="article:published_time" content="2025-04-10T00:00:00+00:00"><meta property="article:modified_time" content="2025-04-10T00:00:00+00:00"></head><body><div class=top-menu><div class=menu-left><a href=/ class=home-link><img src=# alt class=menu-icon>
MariaDB for Universities Program: Course Material</a></div><div class=menu-right><a href=https://mariadb.org>MariaDB Foundation (mariadb.org)</a></div></div><div class=content-wrapper><div class=left-menu><div class=table-of-contents><h2><a href=.>Lesson 3: Database design</a></h2><nav id=TableOfContents><ul><li><a href=#learning-objectives>Learning objectives</a></li><li><a href=#data-modeling-and-database-design>Data modeling and database design</a><ul><li><a href=#database-mindset>Database mindset</a></li><li><a href=#naming-convention>Naming convention</a></li><li><a href=#table-design>Table design</a></li><li><a href=#data-relationships>Data relationships</a></li><li><a href=#third-normal-form-3nf>Third normal form (3NF)</a></li><li><a href=#character-set-and-collation>Character set and collation</a></li><li><a href=#indexing-concept>Indexing concept</a></li><li><a href=#index-best-practices>Index best practices</a></li><li><a href=#file-storage>File storage</a></li><li><a href=#database-design-summary>Database design summary</a></li></ul></li><li><a href=#lesson-summary>Lesson summary</a></li><li><a href=#lab-exercises>Lab exercises</a></li></ul></nav></div></div><div class=main-content><nav class=breadcrumb><a href=/>MariaDB for Universities Course Material</a>
>
<a href=/dev/>MariaDB Developer Course</a>
> <span class=current>Lesson 3: Database design</span></nav><h1>Lesson 3: Database design</h1><h1 id=database-design>Database design</h1><h2 id=learning-objectives>Learning objectives</h2><ul><li>Explain the purpose of data modeling and database design</li><li>Describe how MariaDB data types affect performance</li><li>Assign appropriate column options</li></ul><h2 id=data-modeling-and-database-design>Data modeling and database design</h2><h3 id=database-mindset>Database mindset</h3><ul><li><p><strong>Redundant data is eliminated</strong><br>Easier updating and maintenance</p></li><li><p>Atomicity, Isolation, Consistency, Durability (ACID)</p></li><li><p>Field have explicit data types</p></li><li><p>Flexible and easy to query programmatically</p></li><li><p>Accessible by multiple remote, differing clients</p></li><li><p>Multiple ways to view the same dataset</p></li><li><p>Indexable</p></li></ul><h3 id=naming-convention>Naming convention</h3><p>Consistent, Descriptive Names Reduce Mistakes</p><p>Plural Form for Table Names (e.g., <code>products</code>)</p><p>Singular Form for Column Names (e.g., <code>name_last</code>, <code>email</code>)</p><p>Alphabetical Order for Link Tables (e.g., <code>posts_users</code>)</p><p>Long, descriptive names are better than short, cryptic ones. Use aliases.</p><p>Use consistent naming for an <code>id</code> column and its references as <code>table_id</code>.</p><h3 id=table-design>Table design</h3><h4 id=normalization>Normalization</h4><ul><li>Process of Optimizing and Factoring a Schema<ul><li>1:1, 1:n and n:n</li><li><code>1NF</code> / <code>2NF</code> / <code>3NF</code></li></ul></li><li>Makes a Data Set Smaller by Eliminating Redundant or Duplicate Data<ul><li>Problem if Data is Smaller than Key</li></ul></li><li>Ensures Data Set Consistency and Integrity</li><li>Often Improves Concurrency by Reducing Locking Overhead - Not Always</li><li>Increases Number of Tables and Associated Maintenance</li></ul><h4 id=denormalization>Denormalization</h4><ul><li>Complete Normalization can Slow Queries</li><li>More Complex <code>JOIN</code> Queries are Drains and Harder to Maintain<ul><li>Adding Redundant Data Back to Simplify</li><li>Problems with <code>JOIN</code> Queries</li><li>Combine 1:n Relationships</li><li>Add Pre-Computed Columns</li><li>Use Fake Materialized Views</li></ul></li><li>Denormalization Adds Redundant Data to Schema<ul><li>Write Queries become More Complex or Numerous as Multiple Locations must be Maintained</li></ul></li><li>It&rsquo;s Easier to Normalize First, Then Denormalize when Appropriate</li></ul><h3 id=data-relationships>Data relationships</h3><p><strong>One-to-One or Zero-to-One</strong><br>Stored generally in the same table<br>May be split for performance</p><p><strong>One-to-Many or Zero-to-Many</strong><br>Many in separate table referenced by one primary key (i.e., a foreign key)</p><p><strong>Many-to-Many</strong><br>Several tables with one operating as a link<br>Linked tables often have a composite primary key</p><h3 id=third-normal-form-3nf>Third normal form (3NF)</h3><h4 id=remove-horizontal-redundancies>Remove horizontal redundancies</h4><p><strong>First normal form</strong></p><p>No single column with more than a single item</p><p>No two columns with the same information</p><h4 id=each-row-must-be-unique>Each row must be unique</h4><p><strong>First normal form</strong></p><p>Use a primary key: Natural or surrogate like <code>AUTO_INCREMENT</code></p><h4 id=remove-vertical-redundancy>Remove vertical redundancy</h4><p><strong>Second normal form</strong></p><p>Same value should not repeat across rows</p><p>Data type can play a role (e.g., <code>ENUM</code>)</p><h4 id=remove-vertical-redundancy-1>Remove vertical redundancy</h4><p><strong>Third normal form</strong></p><p>Columns not dependent on primary key are removed</p><h3 id=character-set-and-collation>Character set and collation</h3><p>Character set may be global or for schema, table or column</p><p>Multi-byte character sets increase disk storage and working memory requirements</p><ul><li>UTF-8 Requires 3 or 4 bytes per character</li></ul><p>Collations affect string comparison (character order)</p><p>Collations can be changed for a query:</p><div class=highlight><pre tabindex=0 style=background-color:#f0f0f0;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#007020;font-weight:700>SELECT</span><span style=color:#bbb> </span><span style=color:#666>*</span><span style=color:#bbb> </span><span style=color:#007020;font-weight:700>FROM</span><span style=color:#bbb> </span>table1<span style=color:#bbb> </span><span style=color:#007020;font-weight:700>ORDER</span><span style=color:#bbb> </span><span style=color:#007020;font-weight:700>BY</span><span style=color:#bbb> </span>col1<span style=color:#bbb>
</span></span></span><span style=display:flex><span><span style=color:#bbb></span><span style=color:#007020;font-weight:700>COLLATE</span><span style=color:#bbb> </span>latin1_german2_ci;<span style=color:#bbb>
</span></span></span></code></pre></div><h3 id=indexing-concept>Indexing concept</h3><p><strong>Poor Indexing #1 Reason For Poor Performance</strong></p><p>Like most RDBMS, MariaDB resolves queries faster with indexes</p><p>Without Indexes, MariaDB does slow Full Table Scans</p><p>Indexes can be for a Column or Multiple Columns (i.e., Composites)</p><p>In InnoDB, the primary key is added to the end of all indexes on disk</p><p>Avoid Indexing Excessively or Arbitrarily</p><ul><li>Read/Write Tradeoff</li><li>Space/Performance Tradeoff</li></ul><p>Regularly Remove Unused or Redundant Indexes</p><p>Avoid foreign keys due to performance overhead</p><h3 id=index-best-practices>Index best practices</h3><p>Every table should have a Primary Key</p><ul><li>This is particularly important for Replication</li></ul><p>Foreign Key should have an index as it helps in the query joins</p><p>Create an index on the columns that are frequently used in the <code>WHERE</code> clause of the queries</p><p>Consider <code>ORDER BY</code> clause for possible composite Indexes</p><ul><li>This is very useful of the <code>WHERE</code> clause does very less filtering and the <code>ORDER BY</code> matches exactly with the <code>COMPOSITE</code> Index (Same order of keys, all <code>ASC</code>, all <code>DESC</code> etc.)</li></ul><p><code>INDEX</code> on an <code>EXPRESSION</code>, also known as <code>FUNCTION</code> based indexes</p><ul><li><code>UPPER(First_Name)</code>, <code>SUBSTR(Account_No, 3, 5)</code></li><li>Not available directly, but can be achieved by defining a <code>VIRTUAL</code> column on the table and creating an index on it.</li></ul><p><code>EXPLAIN</code> / <code>ANALYZE</code> and <code>PROFILING</code> queries are the most important tools available when looking for possible Index candidates</p><h3 id=file-storage>File storage</h3><p><strong>Store Files in <code>BLOB</code> Useful</strong></p><ul><li>Included in Back-Up and Replication</li><li>Guaranteed to be Consistent with Other Data</li></ul><p><strong>Store Files in <code>BLOB</code> has Problems</strong></p><ul><li>Database gets Too Large</li><li>MariaDB Can&rsquo;t do Partial Field Read — MyISAM Reads Entire File</li><li>InnoDB can Skip if Field Not Referenced in Query</li></ul><p><strong>Can Minimize by putting Files in Separate Table (1:1 relationship)</strong></p><p><strong>Store Files in File System and File Name and Path in Table</strong></p><ul><li>Database is Smaller and More Efficient</li><li>Organize Separate Back-Up, possibly with External Locking for Consistency</li></ul><h3 id=database-design-summary>Database design summary</h3><p>Adjust schema as needs change</p><ul><li>Don’t over plan or over anticipate for unknown requirements</li><li>A well normalized schema is usually easy to change</li></ul><p>Consider data growth (a large dataset makes migrations slower and more difficult)</p><p>Don’t optimize prematurely (makes future redesigns more difficult)</p><p>Consider early on the limitations of the system</p><ul><li>Storage engines may benefit from some non-3NF practices</li></ul><p>Minimize table size on disk and in memory</p><p>Archive table data if possible and appropriate</p><p>Remove duplicate or unused indexes</p><ul><li>No need to index a column if it’s first field in another index</li></ul><p>Use appropriate data types — smaller is better</p><p>Consider sharding large tables across multiple servers</p><p>Use auto generated columns when possible</p><ul><li>Act as function based indexes when indexed</li></ul><h2 id=lesson-summary>Lesson summary</h2><ul><li>Explain the purpose of data modeling and database design</li><li>Describe how MariaDB data types affect performance</li><li>Assign appropriate column options</li></ul><h2 id=lab-exercises>Lab exercises</h2><ul><li>3-1 Designing a Database in Third Normal Form</li></ul><hr><p>For academic and non-commercial usage, licensed under CC BY-NC-SA 4.0 by MariaDB plc.</p></div><div class=right-menu><div class=quick-links><a href=https://github.com/MariaDB/mariadb-for-universities/blob/main/mariadb-dev-03-database-design.md class="icon-link edit-page">View page source</a>
<a href=https://github.com/MariaDB/mariadb-for-universities/edit/main/mariadb-dev-03-database-design.md class="icon-link view-source">Edit this page</a>
<a href="https://github.com/MariaDB/mariadb-for-universities/issues/new?title=Course%20Material%20issue%20for%20Lesson%203%3a%20Database%20design&body=I%20found%20an%20issue%20with%20the%20documentation%20for%20Lesson%203%3a%20Database%20design.%0A%0A%0A%0A---%0A%0AThis%20issue%20is%20related%20to%20the%20following%20page%3A%0A%0Ahttps%3a%2f%2funi.mariadb.org%2fdev%2fdatabase-design%2f" class="icon-link create-doc">Create material issue</a>
<a href=javascript:void(0) onclick=printSection() class="icon-link print">Print entire section</a></div></div></div><script>function printSection(){const e=document.querySelector(".left-menu"),t=document.querySelector(".right-menu"),n=e.style.display,s=t.style.display;e.style.display="none",t.style.display="none",window.print(),e.style.display=n,t.style.display=s}</script></body></html>